#ifndef _EXPORTER_H
#define _EXPORTER_H
#include <fstream>
#include <iostream>
#include <vector>
#include "Point3d.h"
using namespace std;

class Face{
  public:
    int v[3];
    Face(){
    v[0]=v[1]=v[2]=0;
    }
    Face(int v0,int v1,int v2){
      v[0]=v0;
      v[1]=v1;
      v[2]=v2;
    }
};
// OBJ Model Exporter
class Exporter {
	ofstream file;
	vector<Point3d> points;
	vector<Face> faces;
	void writeVertices() {
		for(unsigned int i=0; i<points.size(); i++)
		{
			file<<"v "<<points[i].x<<" "<<points[i].y<<" "<<points[i].z;
			file<<endl;
		}
	}
	void writeFaces() {
		for(unsigned int i=0;i<faces.size();i++){
		  file<<"f "<<faces[i].v[0]<<" "<<faces[i].v[1]<<" "<<faces[i].v[2];
			file<<endl;
		}
	}
	int findPoint(Point3d *a){
	 int found=0;
	 for(unsigned int i=0;i<points.size();i++){
	   if(a->x==points[i].x&&a->y==points[i].y&&a->z==points[i].z)
	   {
	     found=i+1;//zapisz id znalezionego powiekszone o 1
	      break;
	   }
	 }
	 return found;
	}
	void addTriangle(Point3d a,Point3d b,Point3d c) {
		//dla kazdego pkt trojkata sprawdz czy istnieje juz na liscie points
		Face f;
		Point3d* p[3]={&a,&b,&c};
		int ids[3];
		for(unsigned int i=0;i<3;i++)
		  ids[i]=findPoint(p[i]);
		for(unsigned int i=0;i<3;i++){
		   if(ids[i]==0){//not found
		      switch(i){
			case 0: points.push_back(a); break;
			case 1: points.push_back(b); break;
			case 2: points.push_back(c); break;
		      }
		      points.push_back(a);
		      f.v[i]=points.size();
		   }else f.v[i]=ids[i];
		}
		faces.push_back(f);
	}
	void exportBranch(BranchModel *bm, Parameters *params)
	{
		TrunkParameters *tp=params->tp;
		int nodeModelListLen = bm->nodeModelList.size();
		// i - numer okregu w galezi
		for(int i=0; i<nodeModelListLen-1; i++)
		{
			NodeModel *root= bm->nodeModelList.at(i);
			NodeModel *child = bm->nodeModelList.at(i+1);
			int index = child->segment->index;

#define GV(point,tpoint) point.x+tpoint.x,point.y+tpoint.y,point.z+tpoint.z
			for (int i0 = 0; i0 < tp->circlePoints; i0++) {
				int j0 = (index + i0) % tp->circlePoints;
				int i1 = (i0+1)%tp->circlePoints;
				int j1 = (j0+1)%tp->circlePoints;

				Point3d rootAbs, childAbs;
				rootAbs = bm->getAbsoluteNodePosition(root);
				childAbs = bm->getAbsoluteNodePosition(child);

				Point3d a(GV(rootAbs, (*root->segment->circlePts[i0]) ));
				Point3d b(GV(childAbs, (*child->segment->circlePts[j0])));
				Point3d c(GV(childAbs, (*child->segment->circlePts[j1])));
				addTriangle(a,b,c);

				Point3d d(GV(rootAbs, (*root->segment->circlePts[i1])));
				Point3d e(GV(childAbs, (*child->segment->circlePts[j1])));
				Point3d f(GV(rootAbs, (*root->segment->circlePts[i0])));
				addTriangle(d,e,f);
			}
#undef GV
		}
	}
public:
	void init(char *filename) {
		file.open(filename);
		points.clear();
	}
	void exportTrunk(Model3d *model, Parameters *params)
	{
		for(unsigned int i=0; i<model->branches.size(); i++)
			exportBranch(model->branches[i], params);
	}

	void save() {
		printf("saving...");
		if(file.is_open()==false) {
			printf("Exporter error file is not opened");
			return;
		}
		file<<"# This model was generated by Treemaker O&O."<<endl;
		file<<"# List of Vertices, with (x,y,z) coordinates"<<endl;
		writeVertices();
		file<<"# Face Definitions (v1-id v2-id v3-id)"<<endl;
		writeFaces();
		file<<"# End of file"<<endl;
		file.close();
		points.clear();
		printf("done\n");
	}
};
#endif